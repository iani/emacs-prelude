* TODO Try Orgstruct, Outshine, Outorg or Poporg for elisp files instead of Babel
:PROPERTIES:
:DATE:     <2014-03-03 Mon 13:50>
:END:

http://orgmode.org/worg/org-tutorials/org-outside-org.html

* Generic Emacs Customization
** Use replace-colorthemes for large selection of themes, Emacs 24-style

#+BEGIN_SRC elisp
;;  (add-to-list 'custom-theme-load-path
;;               (file-name-as-directory "/Users/iani2/Documents/Dev/Emacs/replace-colorthemes/"))
#+END_SRC

#+RESULTS:

Some themes (besides solarized-dark and zenburn):
- resolve

** Theme: resolve
#+BEGIN_SRC elisp
;; (load-theme 'solarized-dark)
;; (load-theme 'resolve)
#+END_SRC

** Internationalization: Set Mac OS native fonts for japanese/greek
:PROPERTIES:
:DATE:     <2013-12-08 Sun 15:12>
:END:

Here is a solution that works fine for displaying Latin, Greek and Japanese texts in the same buffer.  The Menlo font displays Greek clearly and smoothly, and since it is a mono-space font, it also works well in tables.  The two lisp expressions have to be evaluated in the following order for this to work.

#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default"
                  'japanese-jisx0208
                  '("Hiragino Mincho Pro" . "iso10646-1"))
(set-fontset-font "fontset-default"
                  'greek
 ;; Note: iso10646-1 = Universal Character set (UCS)
 ;; It is compatible to Unicode, in its basic range
                  '("Menlo" . "iso10646-1"))
#+END_SRC

#+RESULTS:

Links for further reading:

http://sunsite.univie.ac.at/textbooks/emacs/emacs_22.html#SEC203
http://www.gnu.org/software/emacs/manual/html_node/emacs/Modifying-Fontsets.html
For Greek see: http://iris.math.aegean.gr/~atsol/emacs-unicode/

** Maximize/toggle frame
#+BEGIN_SRC emacs-lisp
;; (maximize-frame) ;; maximize frame on startup
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
(tool-bar-mode -1)
#+END_SRC

#+RESULTS:

** Movement: backward-sentence, forward-sentence

Bind backward-sentence and forward-sentence in 2 different ways:

1. Control-shift-f and b in analogy to control-b/f and meta-b/f (character and word backward and forward).
2. Meta-[ and ] in analogy to Meta-shift-[ and ] (org-element backward and forward).

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-B") 'backward-sentence)
  (global-set-key (kbd "M-F") 'forward-sentence)
  (global-set-key (kbd "M-[") 'backward-sentence)
  (global-set-key (kbd "M-]") 'forward-sentence)
#+END_SRC

#+RESULTS:
: forward-sentence

** Insert timestamp (C-c C-x C-t)

#+BEGIN_SRC emacs-lisp
  (defun insert-timestamp (&optional type)
    "Insert a timestamp."
    (interactive "P")
    (insert (format-time-string "%a, %b %e %Y, %R %Z")))

  (global-set-key (kbd "C-c C-x t") 'insert-timestamp)
#+END_SRC

#+RESULTS:
: insert-timestamp

** Generic Packages

*** Install el-get for installing of packages from github etc.

See: https://github.com/dimitri/el-get/blob/master/README.md

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/el-get/el-get")

  (unless (require 'el-get nil 'noerror)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
      (goto-char (point-max))
      (eval-print-last-sexp)))

  (add-to-list 'el-get-recipe-path "~/.emacs.d/el-get-user/recipes")
  (el-get 'sync)
#+END_SRC

#+RESULTS:

*** Bring elisp up-to-date: dash.el

#+BEGIN_QUOTE
A modern list api for Emacs. No 'cl required.
#+END_QUOTE

See: https://github.com/magnars/dash.el#functions

Used in my packages as well as in projectile and other packages.

I load it here to have it available when experimenting with code.

#+BEGIN_SRC emacs-lisp
(require 'dash)
#+END_SRC

#+RESULTS:
: dash

*** desktop

Save desktop between sessions.  To clear desktop: M-x desktop-clear

#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
#+END_SRC

#+RESULTS:
: t

*** Switch window

#+BEGIN_SRC emacs-lisp
  (require 'switch-window)
  (global-set-key (kbd "C-x o") 'switch-window)
#+END_SRC

#+RESULTS:
: switch-window

*** Buffer-move, windmove, buffer switching

- windmove (package) :: Use cursor keys to switch cursor position between windows.  Bound to =control-super-<cursorkey>=.
- buffer-move (package) :: Use cursor keys to switch buffer position between windows.  Bound to =fn-shift-<cursor key>=.
- next-buffer, previous-buffer (built-in commands) :: Use cursor keys to switch to previous/next buffer in same window.  Bound to =function-super-<cursor key>=

#+BEGIN_SRC emacs-lisp

  (global-set-key (kbd "<C-s-up>") 'windmove-up)
  (global-set-key (kbd "<C-s-down>") 'windmove-down)
  (global-set-key (kbd "<C-s-right>") 'windmove-right)
  (global-set-key (kbd "<C-s-left>") 'windmove-left)

  (require 'buffer-move)
  (global-set-key (kbd "<S-prior>") 'buf-move-up)
  (global-set-key (kbd "<S-next>") 'buf-move-down)
  (global-set-key (kbd "<S-end>") 'buf-move-right)
  (global-set-key (kbd "<S-home>") 'buf-move-left)

  (global-set-key (kbd "<s-home>") 'previous-buffer)
  (global-set-key (kbd "<s-end>") 'next-buffer)
#+END_SRC

#+RESULTS:
: next-buffer

*** Completion help: icicles, imenu+, auto-complete, ido, guide-key

#+BEGIN_SRC emacs-lisp
  (require 'ido)
  (require 'imenu+)
  (require 'auto-complete)
  (ido-mode t)
  ;; (icicle-mode) ;; broken on Wed, Mar  5 2014, after loading one-key, hexrgb
  ;; could not fix
  ;; guide-key causes errating post tempo at SC post buf. Therefore avoid!
  ;; (require 'guide-key)
  ;; (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "H-h" "H-m" "H-p" "H-d" "C-c"))
  ;;  (guide-key-mode 1)  ; Enable guide-key-mode
  ;; (yas-global-mode) ; interferes with auto-complete in elisp mode.
#+END_SRC

*** File-system navigation: projectile, helm

**** projectile

#+BEGIN_SRC emacs-lisp
  (setq projectile-completion-system 'grizzl)

  (defun projectile-dired-project-root ()
    "Dired root of current project.  Can be set as value of
  projectile-switch-project-action to dired root of project when switching.
  Note: projectile-find-dir (with grizzl) does not do this, but it
  asks to select a *subdir* of selected project to dired."
    (interactive)
    (dired (projectile-project-root)))

  (setq projectile-switch-project-action 'projectile-commander)

  (defun projectile-post-project ()
    "Which project am I actually in?"
    (interactive)
    (message (projectile-project-root)))

  (defun projectile-add-project ()
    "Add folder of current buffer's file to list of projectile projects"
    (interactive)
    (if (buffer-file-name (current-buffer))
        (projectile-add-known-project
         (file-name-directory (buffer-file-name (current-buffer))))))

  (global-set-key (kbd "H-p c") 'projectile-commander)
  (global-set-key (kbd "H-p h") 'helm-projectile)
  (global-set-key (kbd "H-p s") 'projectile-switch-project)
  (global-set-key (kbd "H-p d") 'projectile-find-dir)
  (global-set-key (kbd "H-p f") 'projectile-find-file)
  (global-set-key (kbd "H-p w") 'projectile-post-project)
  (global-set-key (kbd "H-p D") 'projectile-dired-project-root)
  (global-set-key (kbd "H-p +") 'projectile-add-project)
  (global-set-key (kbd "H-p -") 'projectile-remove-known-project)
  (global-set-key (kbd "H-p g") 'projectile-grep)

#+END_SRC

**** helm

NOTE: helm-swoop must be installed from:
https://raw.github.com/ShingoFukuyama/helm-swoop/master/helm-swoop.el
or
https://raw.github.com/ShingoFukuyama/helm-swoop/
#+BEGIN_SRC emacs-lisp
  ;; must call these to initialize  helm-source-find-files

  (require 'helm-files) ;; (not auto-loaded by system!)
  (require 'helm-projectile)
  (require 'helm-swoop) ;; must be put into packages
  ;; Don't bicker if not in a project:
  (setq projectile-require-project-root)

  ;; Add add-to-projectile action after helm-find-files.
  (let ((find-files-action (assoc 'action helm-source-find-files)))
    (setcdr find-files-action
            (cons
             (cadr find-files-action)
             (cons '("Add to projectile" . helm-add-to-projectile)
                   (cddr find-files-action)))))

  ;; Use helm-find-files actions in helm-projectile
  (let ((projectile-files-action (assoc 'action helm-source-projectile-files-list)))
      (setcdr projectile-files-action (cdr (assoc 'action helm-source-find-files))))

  (defun helm-add-to-projectile (path)
    "Add directory of file to projectile projects.
  Used as helm action in helm-source-find-files"
    (projectile-add-known-project (file-name-directory path)))

  (global-set-key (kbd "H-h p") 'helm-projectile)
  (global-set-key (kbd "H-h g") 'helm-do-grep)
  (global-set-key (kbd "H-h f") 'helm-find-files)
  (global-set-key (kbd "H-h r") 'helm-resume)
  (global-set-key (kbd "H-h b") 'helm-bookmarks)
  (global-set-key (kbd "H-h l") 'helm-buffers-list)
  (global-set-key (kbd "H-M-h") 'helm-M-x)
  (global-set-key (kbd "H-h w") 'helm-world-time)
  (global-set-key (kbd "H-h s") 'helm-swoop)

  (setq display-time-world-list
        '(("America/Los_Angeles" "Santa Barbara")
          ("America/New_York" "New York")
          ("Europe/London" "London")
          ("Europe/Lisbon" "Lisboa")
          ("Europe/Madrid" "Barcelona")
          ("Europe/Paris" "Paris")
          ("Europe/Berlin" "Berlin")
          ("Europe/Rome" "Rome")
          ;; ("Europe/Albania" "Gjirokastra") ;; what city to name here?
          ("Europe/Athens" "Athens")
          ("Asia/Calcutta" "Kolkatta")
          ("Asia/Jakarta" "Jakarta")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Tokyo" "Tokyo")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (message "%s" display-time-world-list)
#+END_SRC

#+RESULTS:
: ((America/Los_Angeles Seattle) (America/New_York New York) (Europe/London London) (Europe/Paris Paris) (Asia/Calcutta Bangalore) (Asia/Tokyo Tokyo))

*** Note on icicle key bindings and org-mode

C-c ' in org mode runs the command org-edit-special, for editing babel commands and other blocks.  To avoid conflict with icicles binding of the same key to icicle-occur, remap the latter to something else (e.g. C-c C-M-'), like this:
1. type M-x customize-group <RET> Icicles-Key-Bindings <RET>
2. Scroll down to Icicle Top Level Key Bindings, open the list, find icicle-occur, enter C-c C-M-' to the =Key:= field, go to top of buffer, use the =State= button to save this.

See also discussion here: http://www.emacswiki.org/emacs/Icicles_-_Key_Binding_Discussion
The relevant part is cited below:

#+BEGIN_QUOTE
But what is the best way to remove an internal value in the option `icicle-top-level-key-bindingsâ€™? It is a quite big list in its value. If I choose to remove that specific line through customize that variable, it would make my init file un-readable. So I need to write some function to make it in the runtime. Here is my function:
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (eval-after-load "icicles-opt.el"
    (add-hook
     'icicle-mode-hook
     (lambda ()
       (setq my-icicle-top-level-key-bindings
             (mapcar (lambda (lst)
                       (unless (string= "icicle-occur" (nth 1 lst)) lst))
                     icicle-top-level-key-bindings))
       (setq icicle-top-level-key-bindings my-icicle-top-level-key-bindings) )))

;;  (icy-mode)
#+END_SRC

*** lacarte: select menu items from the keyboard (good for org-mode with imenu)

#+BEGIN_SRC emacs-lisp
(require 'lacarte)
(global-set-key [?\e ?\M-x] 'lacarte-execute-command)
#+END_SRC

*** Ido-imenu command and jump back after completion, by Magnar Sveen, and others.

Disabled.

#+BEGIN_SRC elisp
  ;;; ido-imenu
  (defun ido-imenu ()
    "Update the imenu index and then use ido to select a symbol to navigate to.
  Symbols matching the text at point are put first in the completion list."
    (interactive)
    (imenu--make-index-alist)
    (let ((name-and-pos '())
          (symbol-names '()))
      (flet ((addsymbols
            (symbol-liost)
            (when (listp symbol-list)
              (dolist (symbol symbol-list)
                (let ((name nil) (position nil))
                  (cond
                   ((and (listp symbol) (imenu--subalist-p symbol))
                    (addsymbols symbol))

                   ((listp symbol)
                    (setq name (car symbol))
                    (setq position (cdr symbol)))

                   ((stringp symbol)
                    (setq name symbol)
                    (setq position
                          (get-text-property 1 'org-imenu-marker symbol))))

                  (unless (or (null position) (null name))
                    (add-to-list 'symbol-names name)
                    (add-to-list 'name-and-pos (cons name position))))))))
        (addsymbols imenu--index-alist))
  ;; If there are matching symbols at point, put them at the beginning of `symbol-names'.
      (let ((symbol-at-point (thing-at-point 'symbol)))
        (when symbol-at-point
          (let* ((regexp (concat (regexp-quote symbol-at-point) "$"))
                 (matching-symbols
                  (delq nil (mapcar (lambda (symbol)
                                      (if (string-match regexp symbol) symbol))
                                    symbol-names))))
            (when matching-symbols
              (sort matching-symbols (lambda (a b) (> (length a) (length b))))
              (mapc
               (lambda (symbol)
                 (setq symbol-names (cons symbol (delete symbol symbol-names))))
               matching-symbols)))))
      (let* ((selected-symbol (ido-completing-read "Symbol? " symbol-names))
             (position (cdr (assoc selected-symbol name-and-pos))))
        (goto-char position))))

  ;; Push mark when using ido-imenu

  (defvar push-mark-before-goto-char nil)

  (defadvice goto-char (before push-mark-first activate)
    (when push-mark-before-goto-char
      (push-mark)))

  (defun ido-imenu-push-mark ()
    (interactive)
    (let ((push-mark-before-goto-char t))
      (ido-imenu)))
#+END_SRC

#+RESULTS:
: ido-imenu-push-mark

*** smex (auto-complete minibuffer commands called with Meta-x)

#+BEGIN_SRC emacs-lisp
;; Smex: Autocomplete meta-x command
(global-set-key [(meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(meta x)] 'smex)
                  (smex)))

(global-set-key [(shift meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(shift meta x)] 'smex-major-mode-commands)
                  (smex-major-mode-commands)))
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C-c m") 'helm-mini)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M->") 'mc/mark-more-like-this-extended)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  ;; (global-set-key (kbd "C->") 'mc/mark-next-symbol-like-this)
  ;; (global-set-key (kbd "C->") 'mc/mark-next-word-like-this)

#+END_SRC

*** Whitespace Mode

#+BEGIN_SRC emacs-lisp
  (defun turn-off-whitespace-mode () (whitespace-mode -1))
  (defun turn-on-whitespace-mode () (whitespace-mode 1))
#+END_SRC

*** Key Chords

#+BEGIN_SRC emacs-lisp
  (require 'key-chord)
  (key-chord-mode 1)

  (defun paren-sexp ()
    (interactive)
    (insert "(")
    (forward-sexp)
    (insert ")"))

  (defun code-quote-sexp ()
    (interactive)
    (insert "=")
    (forward-sexp)
    (insert "="))

  (key-chord-define-global "jk"     'ace-jump-char-mode)
  (key-chord-define-global "jj"     'ace-jump-word-mode)
  (key-chord-define-global "jl"     'ace-jump-line-mode)

  (key-chord-define-global "hj"     'undo)

  (key-chord-define-global "{}"     "{   }\C-b\C-b\C-b")
  (key-chord-define-global "()"     'paren-sexp)
  (key-chord-define-global "(_"     "()\C-b")
  (key-chord-define-global "-="     'code-quote-sexp)
  ;; to add: quote, single quote around word/sexp
  ;; Exit auto-complete, keeping the current selection,
  ;; while avoiding possible side-effects of TAB or RETURN.
  (key-chord-define-global "KK"      "\C-f\C-b")
  ;; Trick for triggering yasnippet when using in tandem with auto-complete:
  ;; Move forward once to get out of auto-complete, then backward once to
  ;; end of keyword, and enter tab to trigger yasnippet.
  (key-chord-define-global "KL"      "\C-f\C-b\C-i")

  ;; Jump to any symbol in buffer using ido-imenu
  (key-chord-define-global "KJ"      'ido-imenu)
#+END_SRC

*** hl-sexp mode (also: highlight-sexps)

Highlight expressions enclosed by (), {} or [] in code.

There exist 2 versions:

1. hl-sexp package available from elpa.
   Package name: hl-sexp
   Mode name: hl-sexp-mode
2. highlight-sexps.el, from http://www.emacswiki.org/emacs/HighlightSexp.
   Package name: highlight-sexps
   Mode name: highlight-sexps-mode

highlight-sexps.el looks nicer, because it highlights both the innermost s-expression and the one enclosing it, and it does not un-highlight the line where the cursor is on.  But it sometimes stops working.  So I use hl-sexp

#+BEGIN_SRC emacs-lisp
  (require 'hl-sexp)
  ;; (require 'highlight-sexps)
  ;; Include color customization for dark color theme here.
  (custom-set-variables
   '(hl-sexp-background-colors (quote ("gray0"  "#0f003f"))))
#+END_SRC

*** Directory/Buffer navigation: Dired+, Dirtree, Speedbar
**** Dired+, Dirtree, Speedbar

Note about dirtree:  Very handy.  There are several versions out there, and there is also a different package under the same name.  Not all versions work.  This one works for me: https://github.com/rtircher/dirtree.  I installed it manually (not via =el-get=, el-get's registered versions of dirtree resulted in conflicts.  Dirtree is similar to file-browse mode of speedbar, but it servers a different purpose: With dirtree you can select one or more directories to browse, and keep them all in the sidebar.  Speedbar always shows only the directory of the file of the current buffer.

#+BEGIN_SRC emacs-lisp
  (require 'dired+)
  (require 'dirtree)
  (global-set-key (kbd "H-d d") 'dirtree-show)
  (require 'sr-speedbar)
  (speedbar-add-supported-extension ".sc")
  (speedbar-add-supported-extension ".scd")
  (global-set-key (kbd "H-d H-s") 'sr-speedbar-toggle)
#+END_SRC

**** Dired customization from Healy's startup kit
(From Healy's startup kit)

Note: Perhaps these are not used.  Need to test.

**** Open pdf files with default macos app in dired
:PROPERTIES:
:DATE:     <2013-12-01 Sun 15:01>
:END:

From: http://stackoverflow.com/questions/20019732/define-keybinding-for-dired-to-run-a-command-open-on-the-file-under-the-cur

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "<SPC>")
    (lambda () (interactive)
      (let ((lawlist-filename (dired-get-file-for-visit)))
        (if (equal (file-name-extension lawlist-filename) "pdf")
            (start-process "default-pdf-app" nil "open" lawlist-filename)))))
#+END_SRC

**** Dired
***** TODO Copy folder / file path from DIRED

***** TODO Open home folder in finder

***** TODO Open selected folder or file in finder

***** Dired-x
Dired extensions
#+SOURCE: Dired-x
#+BEGIN_SRC emacs-lisp
  (load "dired-x")
#+END_SRC

#+RESULTS:
: t

***** Dired open multiple files DISABLED
In dired mode, visit all marked files using. Bound to the "F" key.
#+SOURCE: dired-F
#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+END_SRC

#+RESULTS:
: my-dired-find-file

***** Stripe Dired buffers DISABLED
#+name: stripe-dired
#+begin_src [elisp (This part is disabled)]
(require 'stripe-buffer)
(add-hook 'org-mode-hook 'org-table-stripes-enable)
(add-hook 'dired-mode-hook 'stripe-listify-buffer)
#+end_src

*** TODO Fixme minor mode?

http://www.emacswiki.org/emacs/FixmeMode
http://www.emacswiki.org/emacs/fixme-mode.el

Or see: hl-todo, and further packages like it, listed in hl-todo Help file:

- [[http://emacswiki.org/fic-ext-mode.el][fic-ext-mode]]
- [[https://github.com/lewang/fic-mode][fic-mode]]
- [[http://emacswiki.org/FixmeMode][fixme-mode]]
- [[https://github.com/rolandwalker/fixmee][fixmee]]
- see http://emacswiki.org/FixmeMode for more alternatives

If you like this you might also like [[https://github.com/tarsius/orglink][orglink]].
*** Mac-OS extension: Open file in finder

From: http://stackoverflow.com/questions/20510333/in-emacs-how-to-show-current-file-in-finder

#+BEGIN_SRC emacs-lisp
  (defun open-finder ()
    (interactive)
    ;; IZ Dec 25, 2013 (3:25 PM): Making this work in dired:
    (if (equal major-mode 'dired-mode)
        (open-finder-dired)
        (let ((path
               (if (equal major-mode 'dired-mode)
                   (file-truename (dired-file-name-at-point))
                 (buffer-file-name)))
              dir file)
          (when path
            (setq dir (file-name-directory path))
            (setq file (file-name-nondirectory path))
            (open-finder-1 dir file)))))

  (defun open-finder-1 (dir file)
    (message "open-finder-1 dir: %s\nfile: %s" dir file)
    (let ((script
           (if file
               (concat
                "tell application \"Finder\"\n"
                " set frontmost to true\n"
                " make new Finder window to (POSIX file \"" dir "\")\n"
                " select file \"" file "\"\n"
                "end tell\n")
             (concat
              "tell application \"Finder\"\n"
              " set frontmost to true\n"
              " make new Finder window to {path to desktop folder}\n"
              "end tell\n"))))
      (start-process "osascript-getinfo" nil "osascript" "-e" script)))

#+END_SRC
* Customization of Specific Authoring Modes
** SuperCollider
*** Sclang Setup
#+BEGIN_SRC emacs-lisp
;;; Directory of SuperCollider support, for quarks, plugins, help etc.
(defvar sc_userAppSupportDir
  (expand-file-name "~/Library/Application Support/SuperCollider"))

;; Make path of sclang executable available to emacs shell load path
(add-to-list
 'exec-path
 "/Applications/SuperCollider/SuperCollider.app/Contents/Resources/")

;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; overrides alt-meta switch command
(global-set-key (kbd "C-c W") 'sclang-switch-to-workspace)

;; Disable switching to default SuperCollider Workspace when recompiling SClang
(setq sclang-show-workspace-on-startup nil)

;; Save results of sc evaluation in elisp variable for access in emacs
(defvar sclang-return-string  nil
  "The string returned by sclang process after evaluating expressions.")

(defadvice sclang-process-filter (before provide-sclang-eval-results)
  "Pass sc eval return string to elisp by setting sclang-return-string variable."
  (setq sclang-return-string (ad-get-arg 1)))

(ad-activate 'sclang-process-filter)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'sclang)
#+END_SRC

*** SuperCollider-specific minor modes

Paredit mode breaks re-starting sclang! Therefore, do not use it. Paredit-style bracket movement commands d, u, f, b, n, p work in sclang-mode without loading Paredit.

#+BEGIN_SRC emacs-lisp
  ;; paredit mode breaks re-starting sclang! Therefore, do not use it.
  ;; Note: Paredit-style bracket movement commands d, u, f, b, n, p work
  ;; in sclang-mode without loading Paredit.
  ;; (add-hook 'sclang-mode-hook 'paredit-mode)
  (add-hook 'sclang-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'sclang-mode-hook 'hl-sexp-mode)
  ;; sclang-ac-mode is included in sclang-extensions-mode:
  ;; (add-hook 'sclang-mode-hook 'sclang-ac-mode)
  ;; ac mode constantly tries to run code.
  ;; that can lead to loops that hang, for example constantly creating a view.
  ;; (add-hook 'sclang-mode-hook 'sclang-extensions-mode)
#+END_SRC

*** Sclang keyboard shortcuts

#+BEGIN_SRC emacs-lisp
;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; Show workspace
(global-set-key (kbd "C-c C-M-w") 'sclang-switch-to-workspace)
#+END_SRC
** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'hs-minor-mode)
  (global-set-key (kbd "H-l h") 'hs-hide-level)
  (global-set-key (kbd "H-l s") 'hs-show-all)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (require 'paredit)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-whitespace-mode)
  (add-hook 'emacs-lisp-mode-hook 'auto-complete-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** html/css/js

web-beautify.
HTML, CSS, and JavaScript/JSON formatting
https://github.com/yasuyk/web-beautify

Shell command, install js-beautify library:web
: npm -g install js-beautify
Emacs sexp, install emacs web-beautify package:
: (package-install 'web-beautify)

** org-mode
*** Use visual line, whitespace and windmove in org-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'turn-off-whitespace-mode)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

*** Customize Org-mode display

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t) ;; auto-indent text in subtrees
  (setq org-hide-leading-stars t) ;; hide leading stars in subtree headings
;; following broken on Wed, Mar 19 2014, 07:14 GMT:
;;  (setq org-src-fontify-natively t) ;; colorize source-code blocks natively
#+END_SRC

*** Agenda
**** Global key for org-agenda: C-c a
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
#+END_SRC
**** Add, remove, save agenda file list

#+BEGIN_SRC emacs-lisp
  (defvar org-agenda-list-save-path
    "~/.emacs.d/savefile/org-agenda-list.el"
  "Path to save the list of files belonging to the agenda.")

  (defun org-agenda-save-file-list ()
    "Save list of desktops from file in org-agenda-list-save-path"
    (interactive)
    (save-excursion
      (let ((buf (find-file-noselect org-agenda-list-save-path)))
        (set-buffer buf)
        (erase-buffer)
        (print (list 'quote org-agenda-files) buf)
        (save-buffer)
        (kill-buffer)
        (message "org-agenda file list saved to: %s" org-agenda-list-save-path))))

  (defun org-agenda-load-file-list ()
    "Load list of desktops from file in org-agenda-list-save-path"
    (interactive)
    (save-excursion
      (let ((buf (find-file-noselect org-agenda-list-save-path)))
        (set-buffer buf)
        (setq org-agenda-files (eval (read (buffer-string))))
        (kill-buffer)
        (message "org-agenda file list loaded from: %s" org-agenda-list-save-path))))

  (defun org-agenda-add-this-file-to-agenda ()
    "Add the file from the current buffer to org-agenda-files list."
    (interactive)
    (let (path)
      ;; (org-agenda-file-to-front) ;; adds path relative to user home dir
      ;; (message "Added current buffer to agenda files.")
      (let ((path (buffer-file-name (current-buffer))))
        (cond (path
          (add-to-list 'org-agenda-files path)
          (org-agenda-save-file-list)
          (message "Added file '%s' to agenda file list"
                   (file-name-base path)))
              (t (message "Cannot add buffer to file list. Save buffer first."))))))

  (defun org-agenda-remove-this-file-from-agenda (&optional select-from-list)
    "Remove a file from org-agenda-files list.
  If called without prefix argument, remove the file of the current buffer.
  If called with prefix argument, then select a file from org-agenda-files list."
    (interactive "P")
    (let (path)
     (if select-from-list
         (let  ((menu (grizzl-make-index org-agenda-files)))
           (setq path (grizzl-completing-read "Choose an agenda file: " menu)))
       (setq path (buffer-file-name (current-buffer))))
     (setq org-agenda-files
           (remove (buffer-file-name (current-buffer)) org-agenda-files)))
    (org-agenda-save-file-list)
    (message "Removed file '%s' from agenda file list"
             (file-name-base (buffer-file-name (current-buffer)))))

  (defun org-agenda-open-file ()
    "Open a file from the current agenda file list."
    (interactive)
    (let* ((menu (grizzl-make-index org-agenda-files))
          (answer (grizzl-completing-read "Choose an agenda file: " menu)))
      (find-file answer)))

  (defun org-agenda-list-files ()
    "List the paths that are currently in org-agenda-files"
    (interactive)
    (let  ((menu (grizzl-make-index org-agenda-files)))
      (grizzl-completing-read "These are currently the files in list org-agenda-files. " menu)))

  (defun org-agenda-list-menu ()
   "Present menu with commands for loading, saving, adding and removing
  files to org-agenda-files."
   (interactive)
   (let* ((menu (grizzl-make-index
                 '("org-agenda-save-file-list"
                   "org-agenda-load-file-list"
                   "org-agenda-list-files"
                   "org-agenda-open-file"
                   "org-agenda-add-this-file-to-agenda"
                   "org-agenda-remove-this-file-from-agenda")))
          (command (grizzl-completing-read "Choose a command: " menu)))
     (call-interactively (intern command))))

  (global-set-key (kbd "H-a H-a") 'org-agenda-list-menu)

#+END_SRC


*** Calendar framework: Show org agenda in iCal-style layout

#+BEGIN_SRC emacs-lisp
 (require 'calfw-org)
#+END_SRC

*** Global key for cfw org calendar framework): C-c M-a

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-c\M-a" 'cfw:open-org-calendar)
  (global-set-key "\C-c\C-xm" 'org-mark-ring-goto)
#+END_SRC

*** Insert DATE property with current time
:PROPERTIES:
:DATE:     <2014-02-02 Sun 12:19>
:END:

#+BEGIN_SRC emacs-lisp

  (defun org-set-date (&optional inactive property)
    "Set DATE property with current time.  Active timestamp."
    (interactive "P")
    (org-set-property
     (if property property "DATE")
     (let ((stamp (format-time-string (cdr org-time-stamp-formats) (current-time))))
       (if inactive
           (concat "[" (substring stamp 1 -1) "]")
         stamp))))

  ;; Note: This keybinding is in analogy to the standard keybinding:
  ;; C-c . -> org-time-stamp
  (eval-after-load 'org
    '(progn
       (define-key org-mode-map (kbd "C-c C-.") 'org-set-date)
       ;; Prelude defines C-c d as duplicate line
       ;; But we disable prelude in org-mode because of other, more serious conflicts,
       ;; So we keep this alternative key binding:
       (define-key org-mode-map (kbd "C-c d") 'org-set-date)))

#+END_SRC

*** Set DUE property with selected time/date

#+BEGIN_SRC emacs-lisp
  (defun org-set-due-property ()
    (interactive)
    (org-set-property
     "DUE"
     (format-time-string (cdr org-time-stamp-formats) (org-read-date t t))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-.") 'org-set-due-property))
#+END_SRC
*** Log: (simplified alternative to capture)
:PROPERTIES:
:DATE:     <2013-12-07 Sat 21:59>
:ID:       1E0A70E5-7417-48E7-B17A-9C727D995AE4
:END:

Time tasks and keep log file, in a very short way

- Very simple and fast input mechanism
- New task simply also sets the timestamp for the end of the previous one.
- Following properties are set:
  START_TIME (= active timestamp set at time of start)
  END_TIME (= active timestamp set at time of start of next log entry)
  TIME_SPAN (= START_TIME--END_TIME as timestamps)
  DURATION (= START_TIME-END_TIME as hours:minutes)
- Keeps current task in file "stopwatch.txt"
  This is read by geeklet CountUp, to display duration of current task.
  (sh code of geeklet is included below).

**** CountUp geeklet code

#+BEGIN_SRC sh
#!/bin/bash
# Homework countdown
# BETA - I will update this when I get more time
function countdown
{
	CURRENT=$(date -j -f %D_%T $1 +%s)
	TARGET=$(date +%s)
	LEFT=$((TARGET-CURRENT))
	WEEKS=$((LEFT/604800))
	DAYS=$(( (LEFT%604800)/86400))
	HOURS=$(( (LEFT%86400)/3600))
	MINS=$(( (LEFT%3600)/60))
	SECS=$((LEFT%60))

	lblWEEKS="Weeks"
	lblDAYS="Days"

	if [ $DAYS == 1 ]
	then
	lblDAYS="Day"
	fi

	if [ $WEEKS == 1 ]
	then
	lblWEEKS="Weeky"
	fi

	if [ $HOURS -lt 10 ]
	then
		HOURS=0$HOURS
	fi

	if [ $MINS -lt 10 ]
	then
		MINS=0$MINS
	fi


	if [ $SECS -lt 10 ]
	then
		SECS=0$SECS
	fi


	echo $2 $HOURS:$MINS:$SECS
	# Optional extra line between timers
	# echo
}
DATES=( $( cat /Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt ) )
# Even numbered indices are names, odd numbered indices are dates

if [ ${#DATES[@]} == 0 ]
then
echo "No Deadlines!"
return
fi

for (( i = 0 ; i < ${#DATES[@]} ; i+=2 ))
do
countdown ${DATES[i+1]} ${DATES[i]}
done
#+END_SRC

**** emacs-lisp log function
:PROPERTIES:
:ID:       153FC98A-B1A7-40C7-AC3F-6723AFE5DC4F
:eval-id:  3
:END:

#+BEGIN_SRC emacs-lisp
  (defun log (expense)
    "Simple way to capture notes/activities with some extra features:
  - Set task start time
  - Set completion time of previous task.
  - Calculate duration of previous task
  - Write task to stopwatch.txt file for use by geeklet to display task timer
  - If called with prefix argument, prompt for expense value and set expense task.

  TODO: Store timestamp of last task in separate file, so as to be able to retrieve it
  even if the text of the previous entry is corrupt. "
    (interactive "P")

    (let* ((topic (read-from-minibuffer "Enter topic: "))
          (timer-string
           (concat
            (replace-regexp-in-string " " "_" topic)
            (format-time-string ": %D_%T" (current-time)))))
      (if (< (length topic) 1) (setq topic "Untitled task"))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt")
  ;;    (beginning-of-buffer)
  ;;    (kill-line)
      (erase-buffer)
      (insert timer-string)
      (save-buffer)
      (message (concat "Now timing: " timer-string))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/log.org")
      (widen)
      (end-of-buffer)
      (if (> (org-outline-level) 1) (outline-up-heading 100 t))
      (org-set-date t "END_TIME")
      (org-set-property
       "TIMER_SPAN"
       (concat
        (replace-regexp-in-string
         ">" "]"
         (replace-regexp-in-string "<" "[" (org-entry-get (point) "START_TIME")))
        "--"
        (org-entry-get (point) "END_TIME")))
      (let* ((seconds
              (-
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "END_TIME"))))
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "START_TIME"))))
               ))
             (hours (floor (/ seconds 3600)))
             (seconds (- seconds (* 3600 hours)))
             (minutes (floor (/ seconds 60))))
        (org-set-property
         "DURATION"
         (replace-regexp-in-string " " "0" (format "%2d:%2d" hours minutes))))
      (end-of-buffer)
      (insert-string "\n* ")
      (insert-string (replace-regexp-in-string "_" " " timer-string))
      ;;      (insert-string "\n")
      (org-set-date nil "START_TIME")
      (org-set-date t) ;; also set DATE property: for blog entries
      (org-id-get-create)
      (message "testing expense arg: %s %s" expense (equal expense '(4)))
      (cond ((equal expense '(4))
             (org-set-tags-to '("expense"))
             ;; this causes orgmode to prompt of the value of EXPENSE!
             (org-set-property "EXPENSE" nil)   )
            ((equal expense '(16))
             (org-set-tags-to '("email"))
             )
            )
      (org-set-tags-command)
      (org-narrow-to-subtree)
      (goto-char (point-max))
      (org-show-subtree)
      (org-show-entry)
      (save-buffer)))

  (global-set-key (kbd "C-M-l") 'log)
#+END_SRC

*** Org-Babel
**** Org-Babel: enable some languages

Enable some cool languages in org-babel mode.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (sh . t)
   (ruby . t)
   (python . t)
   (perl . t)
   ))
#+END_SRC
**** Org-Babel: load current file

#+BEGIN_SRC emacs-lisp
  (defun org-babel-load-current-file ()
    (interactive)
    (org-babel-load-file (buffer-file-name (current-buffer))))

  ;; Note: Overriding default key binding to provide consistent pattern:
  ;; C-c C-v f -> tangle, C-c C-v C-f -> load
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-v C-f") 'org-babel-load-current-file))
#+END_SRC

#+RESULTS:
: org-babel-load-current-file

*** Orgmode latex customization

#+BEGIN_SRC elisp
;;; Load latex package
(require 'ox-latex)

;;; Use xelatex instead of pdflatex, for support of multilingual fonts (Greek etc.)
(setq org-latex-pdf-process (list "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f"))

;;; Add beamer to available latex classes, for slide-presentaton format
(add-to-list 'org-latex-classes
             '("beamer"
               "\\documentclass\[presentation\]\{beamer\}"
               ("\\section\{%s\}" . "\\section*\{%s\}")
               ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
               ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))

;;; Add memoir class (experimental)
(add-to-list 'org-latex-classes
             '("memoir"
               "\\documentclass[12pt,a4paper,article]{memoir}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
*** Org-crypt: Encrypt selected org-mode entries

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** org-reveal, ox-impress: Export slides for Reveal.js and impress.js from orgmode

Load org-reveal to make slides with reveal.js

https://github.com/yjwen/org-reveal/
https://github.com/kinjo/org-impress-js.el

#+BEGIN_SRC elisp
(require 'ox-reveal)
(require 'ox-impress-js)
#+END_SRC

*** Folding and unfolding, selecting headings

**** Extra shortcut: Widen
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "H-W") 'widen))

#+END_SRC
**** Macro: toggle drawer visibility for this node
:PROPERTIES:
:DATE:     <2013-12-09 Mon 17:19>
:END:

See: http://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode

#+BEGIN_SRC emacs-lisp
  (fset 'org-toggle-drawer
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 3 16 14 tab 24 24] 0 "%d")) arg)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-d") 'org-toggle-drawer))
#+END_SRC

**** Toggle folding of current item (Command and keyboard command)

#+BEGIN_SRC emacs-lisp
  (defun org-cycle-current-entry ()
    "toggle visibility of current entry from within the entry."
    (interactive)
    (save-excursion)
    (outline-back-to-heading)
    (org-cycle))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-/") 'org-cycle-current-entry))
#+end_src

**** Keyboard Command Shortcut: Select heading of this node (for editing)

Note: outline-previous-heading (C-c p) places the point at the beginning of the heading line.  To edit the heading, one has to go past the * that mark the heading.  org-select heading places the mark at the beginning of the heading text and selects the heading, so one can start editing the heading right away.

#+BEGIN_SRC emacs-lisp
  (defun org-select-heading ()
    "Go to heading of current node, select heading."
    (interactive)
    (outline-previous-heading)
    (search-forward (plist-get (cadr (org-element-at-point)) :raw-value))
    (set-mark (point))
    (beginning-of-line)
    (search-forward " "))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-h") 'org-select-heading))
#+END_SRC
*** Encryption

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** Create menu for org-mode entries (lacarte lets you reach it from the keyboard, too)

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda () (imenu-add-to-menubar "Imenu")))
  (setq org-imenu-depth 3)
#+END_SRC

*** Working with icicles in org-mode

**** making icicle-imenu and icicle-occur work with org-mode

#+BEGIN_SRC elisp
  (defun org-icicle-occur ()
    "In org-mode, show entire buffer contents before running icicle-occur.
   Otherwise icicle-occur will not place cursor at found location,
   if the location is hidden."
    (interactive)
    (show-all)
    (icicle-occur (point-min) (point-max))
    (recenter 3))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-'") 'org-icicle-occur))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i o") 'org-icicle-occur))
  (defun org-icicle-imenu (separate-buffer)
    "In org-mode, show entire buffer contents before running icicle-imenu.
  Otherwise icicle-occur will not place cursor at found location,
  if the location is hidden.
  If called with prefix argument (C-u), then:
  - open the found section in an indirect buffer.
  - go back to the position where the point was before the command, in the
    original buffer."
    (interactive "P")
    (show-all)
    (let ((mark (point)))
      (icicle-imenu (point-min) (point-max) t)
      (cond (separate-buffer
             (org-tree-to-indirect-buffer)
             (goto-char mark))
            (t (recenter 4)))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-=") 'org-icicle-imenu))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i m") 'org-icicle-imenu))

  ;; install alternative for org-mode C-c = org-table-eval-formula
  ;; which is stubbornly overwritten by icy-mode.
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-x =") 'org-table-eval-formula))

  ;; this is a redundant second try for the above, to be removed after testing:
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "C-c M-=") 'org-table-eval-formula)))

  ;;; ???? Adapt org-mode to icicle menus when refiling (C-c C-w)
  ;;; Still problems. Cannot use standard org refiling with icicles activated!
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Definitely switch prelude off in org mode, as it totally screws-up key bindings

Especially in the case of Meta-shift-up and Meta-shift-down for spreadsheets.
Have not figured out yet how to override those keys specifically.

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook (lambda () (prelude-mode -1)))
#+END_SRC


**** Providing alternatives for refile and copy using icicles

#+BEGIN_SRC elisp
  (defun org-refile-icy (as-subtree &optional do-copy-p)
    "Alternative to org-refile using icicles.
  Refile or copy current section, to a location in the file selected with icicles.
  Without prefix argument: Place the copied/cut section it *after* the selected section.
  With prefix argument: Make the copied/cut section *a subtree* of the selected section.

  Note 1: If quit with C-g, this function will have removed the section that
  is to be refiled.  To get it back, one has to undo, or paste.

  Note 2: Reason for this function is that icicles seems to break org-modes headline
  buffer display, so onehas to use icicles for all headline navigation if it is loaded."
    (interactive "P")
    (outline-back-to-heading)
    (if do-copy-p (org-copy-subtree) (org-cut-subtree))
    (show-all)
    (icicle-imenu (point-min) (point-max) t)
    (outline-next-heading)
    (unless (eq (current-column) 0) (insert "\n"))
    (org-paste-subtree)
    (if as-subtree (org-demote-subtree)))

  (defun org-copy-icy (as-subtree)
    "Copy section to another location in file, selecting the location with icicles.
  See org-refile-icy."
    (interactive "P")
    (org-refile-icy as-subtree t))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i r") 'org-refile-icy))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i c") 'org-copy-icy))
#+END_SRC

*** Property shortcuts for collaboration: From-To

Note: searchable both with org-mode match: C-c / p and with icicles search,
org-icicle-occur or icicle-occur, here: C-c C-'

#+BEGIN_SRC elisp
  (defun org-from ()
    "Set property 'FROM'."
    (interactive)
    (org-set-property "FROM" (ido-completing-read "From whom? " '("ab" "iz"))))

  (defun org-to ()
    "Set property 'TO'."
    (interactive)
    (org-set-property "TO" (ido-completing-read "To whom? " '("ab" "iz"))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c x f") 'org-from))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c x t") 'org-to))
#+END_SRC

*** fname-find-file-standardized: Consistent multi-component filenames

#+BEGIN_SRC elisp
  (defvar fname-parts-1-2 nil)
  (defvar fname-part-3 nil)
  (defvar fname-root "~/Dropbox/000Workfiles/2014/")
  (defvar fname-filename-components
    (concat fname-root  "00000fname-filename-components.org"))

  (defun fname-find-file-standardized (&optional do-not-update-timestamp)
    (interactive "P")
    (unless fname-part-3 (fname-load-file-components))
    (setq *grizzl-read-max-results* 40)
    (let* ((root fname-root)
           (index-1 (grizzl-make-index
                     (mapcar 'car fname-parts-1-2)))
           (name-1 (grizzl-completing-read "Part 1: " index-1))
           (index-2 (grizzl-make-index (cdr (assoc name-1 fname-parts-1-2))))
           (name-2 (grizzl-completing-read "Part 2: " index-2))
           (index-3 (grizzl-make-index fname-part-3))
           (name-3 (grizzl-completing-read "Part 3: " index-3))
           (path (concat root name-1 "_" name-2 "_" name-3 "_"))
           (candidates (file-expand-wildcards (concat path "*")))
           extension-index extension final-choice)
      (setq final-choice
            (completing-read "Choose file or enter last component: " candidates))
      (cond ((string-match (concat "^" path) final-choice)
             (setq path final-choice))
        (t
         (setq extension (ido-completing-read
                          "Enter extension:" '("org" "el" "html" "scd" "sc" "ck")))
         (setq path (concat path final-choice
                            (format-time-string "_%Y-%m-%d-%H-%M" (current-time))
                            "." extension))))
      (find-file path)
      (unless do-not-update-timestamp
       (set-visited-file-name
        (replace-regexp-in-string
         "_[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}"
         (format-time-string "_%Y-%m-%d-%H-%M" (current-time)) path)))
      (kill-new (buffer-file-name (current-buffer)))))

  (defun fname-load-file-components (&optional keep-buffer)
    (interactive "P")
    (let ((buffer (find-file fname-filename-components)))
      (fname-load-file-components-from-buffer buffer)
      (unless keep-buffer (kill-buffer buffer)))
    (message "file component list updated"))

  (defun fname-load-file-components-from-buffer (buffer)
    (set-buffer buffer)
    (setq fname-parts-1-2 nil)
    (setq fname-part-3 nil)
    (org-map-entries
     (lambda ()
       (let ((plist (cadr (org-element-at-point))))
         (cond
          ((equal (plist-get plist :level) 2)
           (setq fname-parts-1-2
                 (append fname-parts-1-2
                         (list (list (plist-get plist :raw-value))))))
          ((equal (plist-get plist :level) 3)
           (setcdr (car (last fname-parts-1-2))
                   (append (cdar (last fname-parts-1-2))
                           (list (plist-get plist :raw-value))))))))
     "LEVELS1_2")
    (org-map-entries
     (lambda ()
       (let ((plist (cadr (org-element-at-point))))
         (when
             (equal 2 (plist-get plist :level))
           (setq fname-part-3
                 (append fname-part-3 (list (plist-get plist :raw-value)))))))
     "LEVEL3"))

  (defun fname-edit-file-components ()
    (interactive)
    (find-file fname-filename-components)
    (add-to-list 'write-contents-functions
                 (lambda ()
                   (fname-load-file-components-from-buffer (current-buffer))
                   (message "Updated file name components from: %s" (current-buffer))
                   (set-buffer-modified-p nil)))
    ;; Debugging:
    (message "write-contents-functions of file %s are: %s"
             (buffer-file-name) write-contents-functions))
    (defun fname-menu ()
    (interactive)
    (let ((action (ido-completing-read
                   "Choose action: "
                   '("fname-edit-file-components"
                    "fname-load-file-components"
                    "fname-find-file-standardized"))))
      (funcall (intern action))))

  (global-set-key (kbd "H-f f") 'fname-find-file-standardized)
  (global-set-key (kbd "H-f m") 'fname-menu)
  (global-set-key (kbd "H-f e") 'fname-edit-file-components)
  (global-set-key (kbd "H-f l") 'fname-load-file-components)

#+END_SRC

#+RESULTS:
: fname-load-file-components
*** Macro: toggle drawer visibility for this Â§t0 [ label = "label" ];

:PROPERTIES:
:DATE:     <2013-12-09 Mon 17:19>
:END:

See: http://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode

#+BEGIN_SRC elisp
  (fset 'org-toggle-drawer
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 3 16 14 tab 24 24] 0 "%d")) arg)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-d") 'org-toggle-drawer))
#+END_SRC


*** Internal: Load org-pm

#+BEGIN_SRC elisp
  (org-babel-load-file "/Users/iani2/Documents/Dev/Emacs/org-publish-meta/org-pm.org")
#+END_SRC

** Magit (git for emacs) Add git repositories)

Magit config: Manage git repos from inside emacs

#+BEGIN_SRC elisp
(setq magit-repo-dirs
      '(
        "~/Dropbox/000WORKFILES/org"
        "~/Documents/Dev"
        "~/.emacs.d/personal"
))
#+END_SRC

* Postamble

#+BEGIN_SRC elisp
  ;;; org-pm.el ends here
#+END_SRC
