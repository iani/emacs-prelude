* Generic Emacs Customization

** Theme: solarized-dark
#+BEGIN_SRC emacs-lisp
  (load-theme 'solarized-dark)
#+END_SRC
** Internationalization: Set Mac OS native fonts for japanese/greek
:PROPERTIES:
:DATE:     <2013-12-08 Sun 15:12>
:END:

Here is a solution that works fine for displaying Latin, Greek and Japanese texts in the same buffer.  The Menlo font displays Greek clearly and smoothly, and since it is a mono-space font, it also works well in tables.  The two lisp expressions have to be evaluated in the following order for this to work.

#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default"
                  'japanese-jisx0208
                  '("Hiragino Mincho Pro" . "iso10646-1"))
(set-fontset-font "fontset-default"
                  'greek
 ;; Note: iso10646-1 = Universal Character set (UCS)
 ;; It is compatible to Unicode, in its basic range
                  '("Menlo" . "iso10646-1"))
#+END_SRC

Links for further reading:

http://sunsite.univie.ac.at/textbooks/emacs/emacs_22.html#SEC203
http://www.gnu.org/software/emacs/manual/html_node/emacs/Modifying-Fontsets.html
For Greek see: http://iris.math.aegean.gr/~atsol/emacs-unicode/

** Maximize/toggle frame
#+BEGIN_SRC emacs-lisp
(maximize-frame) ;; maximize frame on startup
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
(tool-bar-mode -1)
#+END_SRC

** Generic Packages

*** desktop

Save desktop between sessions.  To clear desktop: M-x desktop-clear

#+begin_src emacs-lisp :tangle yes
(desktop-save-mode 1)
#+end_src

*** finding things: helm, projectile, icicles ... ...

**** ido-mode, imenu(+), auto-complete, yasnippets, icicles
#+BEGIN_SRC emacs-lisp
  (require 'ido)
  (require 'imenu+)
  (require 'auto-complete)
  (ido-mode t)
  (icicle-mode)
  ;; Use grizzl for autocompletion in projectile:

  ;; (yas-global-mode) : interferes with auto-complete in emacs-lisp mode.
#+END_SRC

**** projectile

#+BEGIN_SRC emacs-lisp
  (setq projectile-completion-system 'grizzl)

  (defun projectile-dired-project-root ()
    "Dired root of current project.  Can be set as value of
  projectile-switch-project-action to dired root of project when switching.
  Note: projectile-find-dir (with grizzl) does not do this, but it
  asks to select a *subdir* of selected project to dired."
    (interactive)
    (dired (projectile-project-root)))

  (setq projectile-switch-project-action 'projectile-dired-project-root)

  (defun projectile-post-project ()
    "Which project am I actually in?"
    (interactive)
    (message (projectile-project-root)))

  (global-set-key (kbd "C-c p w") 'projectile-post-project)
  (global-set-key (kbd "C-c p C-d") 'projectile-dired-project-root)
#+END_SRC

**** Helm fast access: helm-meta-x: fn-x, helm-do-grep: ctl-meta-g

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-x") 'helm-M-x)
(global-set-key (kbd "C-M-g") 'helm-do-grep)
#+END_SRC

**** bookmark+

+ Save/post name of currently loaded desktop.
+ Interactive form for selecting/creating a file to save bookmarks to.

#+BEGIN_SRC emacs-lisp

  (defvar bmkp-current-desktop-file nil
    "Store file name of most recently loaded desktop for posting
  with bmkp-post-current-desktop.")

  (defun bmkp-post-current-desktop (list-files-p)
    "Which desktop are we currently in?"
    (interactive "P")
    (cond (bmkp-current-desktop-file
           (message "The current desktop is: %s" bmkp-current-desktop-file)
           (when list-files-p
               (find-file bmkp-current-desktop-file)
               (multi-occur-in-matching-buffers
                (concat "^" (buffer-file-name) "$") "  \"/")
               (kill-buffer (current-buffer)))
           )
      (t (message "No (further) desktop has been loaded since startup."))))

  (defadvice bmkp-jump-desktop (before bmkp-record-current-desktop
                                       (&optional args))
    "Store file name of most recently loaded desktop for posting
  with bmkp-post-current-desktop."
    (setq bmkp-current-desktop-file
          (cdr (assoc 'desktop-file (ad-get-arg 0)))))

  (ad-activate 'bmkp-jump-desktop)

  (defvar bmkp-desktop-save-path
    (file-truename "~/.emacs.d/personal/desktop/")
    "Where bmkp-save-desktop saves desktop bookmarks.")

  (defvar bmkp-last-desktop-name-save-path
    (concat bmkp-desktop-save-path "last-saved-desktop.txt")
    "bmkp-set-desktop-bookmark-w-name saves name of last saved desktop here.
  This is then read by bmkp-save-desktop to provide default for user.")

  (defun bmkp-save-desktop ()
    "Provide list for choosing which desktop to save.
  The list is derived from the contents of ~/.emacs.d/personal/desktop/*.el
  User can create new desktop bookmarks by entering a name not in the list.
  New desktop files are saved in the same directory as above.
  This function derives the name for the file by adding .el to the bookmark name."
    (interactive)
    (let* ((root (file-truename "~/.emacs.d/personal/desktop/"))
           (saved-name-file (concat root "last-desktop-name"))
           (saved-name
            (if (file-exists-p bmkp-last-desktop-name-save-path)
                (save-excursion
                  (let ((buf (find-file-noselect bmkp-last-desktop-name-save-path)))
                    (set-buffer buf)
                    (setq test (eval (read (buffer-string))))
                    (message (buffer-string))
                    (kill-buffer)))
              "desktop"))
         (query-func
          (if (fboundp 'ido-completing-read) 'ido-completing-read 'completing-read))
         (files
          (mapcar
           (lambda (path)
             (cons (file-name-sans-extension (file-name-nondirectory path)) path))
           (file-expand-wildcards (concat root "*.el"))))
         path name)
     (add-to-list 'files (list saved-name))
     (setq name (apply query-func (list "Save to (M-backspace to show existing choices): "
                                        (mapcar (lambda (f) (car f)) files)
                                        nil nil saved-name)))
     (setq path (cdr (assoc name files)))
     (unless path (setq path (concat root name ".el")))
     (bmkp-set-desktop-bookmark-w-name path nil name)))

  ;; mod bmkp-set-desktop-bookmark: add name argument
  (defun bmkp-set-desktop-bookmark-w-name (desktop-file &optional nosavep name)
                                          ; Bound globally to `C-x p K', `C-x r K', `C-x p c K'
    "Save the desktop as a bookmark.
  You are prompted for the desktop-file location and the bookmark name.
  The default value for the desktop-file location is the current value
  of DESKTOP-FILE.  As always, you can use `M-n' to retrieve it.

  With a prefix arg, set a bookmark to an existing DESKTOP-FILE - do not
  save the current desktop; that is, do not overwrite DESKTOP-FLIE.

  If you also use library Icicles, then the desktop files of all
  existing desktop bookmarks are available during the desktop file-name
  completion as proxy candidates.  To see them, use `C-M-_' to turn on
  the display of proxy candidates."
    (interactive
     (progn (unless (condition-case nil (require 'desktop nil t) (error nil))
              (error "You must have library `desktop.el' to use this command"))
            (let ((icicle-proxy-candidates
               (and (boundp 'icicle-mode) icicle-mode
                    (mapcar (lambda (bmk)
                              (bookmark-prop-get
                               bmk 'desktop-file))
                            (bmkp-desktop-alist-only))))
                  (icicle-unpropertize-completion-result-flag  t))
              (list (read-file-name (if current-prefix-arg
                                        "Use existing desktop file: "
                                      "Save desktop in file: ")
                                    nil (if (boundp 'desktop-base-file-name)
                                            desktop-base-file-name
                                          desktop-basefilename) ; Emacs < 22 name.
                                    current-prefix-arg)
                    current-prefix-arg))))
    (save-excursion
      (let ((buf (find-file-noselect bmkp-last-desktop-name-save-path)))
        (set-buffer buf)
        (erase-buffer)
        (insert (concat "\"" name "\""))
        (save-buffer)
        (kill-buffer)))
    (set-text-properties 0 (length desktop-file) nil desktop-file)
    (unless (file-name-absolute-p desktop-file)
      (setq desktop-file  (expand-file-name desktop-file)))
    (unless (or nosavep  (condition-case nil (require 'desktop nil t) (error nil)))
      (error "You must have library `desktop.el' to use this command"))
    (if nosavep
        (unless (bmkp-desktop-file-p desktop-file)
          (error "Not a desktop file: `%s'" desktop-file))
      (let ((desktop-basefilename     (file-name-nondirectory desktop-file)) ; Emacs < 22
            (desktop-base-file-name   (file-name-nondirectory desktop-file)) ; Emacs 23+
            (desktop-dir              (file-name-directory desktop-file))
            (desktop-restore-eager    t)  ; Don't bother with lazy restore.
            (desktop-globals-to-save
             (bmkp-remove-if (lambda (elt) (memq elt bmkp-desktop-no-save-vars))
                             desktop-globals-to-save)))
        (if (< emacs-major-version 22)
            (desktop-save desktop-dir)    ; Emacs < 22 has no locking.
          (desktop-save desktop-dir 'RELEASE))
        (message "Desktop saved in `%s'" desktop-file)))
    (let ((bookmark-make-record-function
           (lexical-let ((df  desktop-file))
             (lambda () (bmkp-make-desktop-record df))))
          (current-prefix-arg 99)) ; Use all bookmarks for completion, for `bookmark-set'.
      (bookmark-set name)))

  (global-set-key (kbd "C-x p C-w") 'bmkp-post-current-desktop)
  (global-set-key (kbd "C-x p C-k") 'bmkp-save-desktop)
#+END_SRC


*** Switch window

#+BEGIN_SRC emacs-lisp
  (require 'switch-window)
  (global-set-key (kbd "C-x o") 'switch-window)
#+END_SRC

*** Note on icicle key bindings and org-mode

C-c ' in org mode runs the command org-edit-special, for editing babel commands and other blocks.  To avoid conflict with icicles binding of the same key to icicle-occur, remap the latter to something else (e.g. C-c C-M-'), like this:
1. type M-x customize-group <RET> Icicles-Key-Bindings <RET>
2. Scroll down to Icicle Top Level Key Bindings, open the list, find icicle-occur, enter C-c C-M-' to the =Key:= field, go to top of buffer, use the =State= button to save this.

See also discussion here: http://www.emacswiki.org/emacs/Icicles_-_Key_Binding_Discussion
The relevant part is cited below:

#+BEGIN_QUOTE
But what is the best way to remove an internal value in the option `icicle-top-level-key-bindingsâ€™? It is a quite big list in its value. If I choose to remove that specific line through customize that variable, it would make my init file un-readable. So I need to write some function to make it in the runtime. Here is my function:
#+END_QUOTE

#+BEGIN_SRC elisp
  (eval-after-load "icicles-opt.el"
    (add-hook
     'icicle-mode-hook
     (lambda ()
       (setq my-icicle-top-level-key-bindings
             (mapcar (lambda (lst)
                       (unless (string= "icicle-occur" (nth 1 lst)) lst))
                     icicle-top-level-key-bindings))
       (setq icicle-top-level-key-bindings my-icicle-top-level-key-bindings) )))

;;  (icy-mode)
#+END_SRC

#+BEGIN_QUOTE
DavidYoung
#+END_QUOTE

*** lacarte: select menu items from the keyboard (good for org-mode with imenu)

#+BEGIN_SRC emacs-lisp
(require 'lacarte)
(global-set-key [?\e ?\M-x] 'lacarte-execute-command)
#+END_SRC

*** Buffer-move, windmove, buffer switching

- windmove (package) :: Use cursor keys to switch cursor position between windows.  Bound to =control-super-<cursorkey>=.
- buffer-move (package) :: Use cursor keys to switch buffer position between windows.  Bound to =fn-shift-<cursor key>=.
- next-buffer, previous-buffer (built-in commands) :: Use cursor keys to switch to previous/next buffer in same window.  Bound to =function-super-<cursor key>=

#+BEGIN_SRC emacs-lisp

  (global-set-key (kbd "<C-s-up>") 'windmove-up)
  (global-set-key (kbd "<C-s-down>") 'windmove-down)
  (global-set-key (kbd "<C-s-right>") 'windmove-right)
  (global-set-key (kbd "<C-s-left>") 'windmove-left)

  (require 'buffer-move)
  (global-set-key (kbd "<S-prior>") 'buf-move-up)
  (global-set-key (kbd "<S-next>") 'buf-move-down)
  (global-set-key (kbd "<S-end>") 'buf-move-right)
  (global-set-key (kbd "<S-home>") 'buf-move-left)

  (global-set-key (kbd "<s-home>") 'previous-buffer)
  (global-set-key (kbd "<s-end>") 'next-buffer)
#+END_SRC

*** Ido-imenu command and jump back after completion, by Magnar Sveen, and others.

Disabled.

#+BEGIN_SRC elisp
  ;;; ido-imenu
  (defun ido-imenu ()
    "Update the imenu index and then use ido to select a symbol to navigate to.
  Symbols matching the text at point are put first in the completion list."
    (interactive)
    (imenu--make-index-alist)
    (let ((name-and-pos '())
          (symbol-names '()))
      (flet ((addsymbols
            (symbol-liost)
            (when (listp symbol-list)
              (dolist (symbol symbol-list)
                (let ((name nil) (position nil))
                  (cond
                   ((and (listp symbol) (imenu--subalist-p symbol))
                    (addsymbols symbol))

                   ((listp symbol)
                    (setq name (car symbol))
                    (setq position (cdr symbol)))

                   ((stringp symbol)
                    (setq name symbol)
                    (setq position
                          (get-text-property 1 'org-imenu-marker symbol))))

                  (unless (or (null position) (null name))
                    (add-to-list 'symbol-names name)
                    (add-to-list 'name-and-pos (cons name position))))))))
        (addsymbols imenu--index-alist))
  ;; If there are matching symbols at point, put them at the beginning of `symbol-names'.
      (let ((symbol-at-point (thing-at-point 'symbol)))
        (when symbol-at-point
          (let* ((regexp (concat (regexp-quote symbol-at-point) "$"))
                 (matching-symbols
                  (delq nil (mapcar (lambda (symbol)
                                      (if (string-match regexp symbol) symbol))
                                    symbol-names))))
            (when matching-symbols
              (sort matching-symbols (lambda (a b) (> (length a) (length b))))
              (mapc
               (lambda (symbol)
                 (setq symbol-names (cons symbol (delete symbol symbol-names))))
               matching-symbols)))))
      (let* ((selected-symbol (ido-completing-read "Symbol? " symbol-names))
             (position (cdr (assoc selected-symbol name-and-pos))))
        (goto-char position))))

  ;; Push mark when using ido-imenu

  (defvar push-mark-before-goto-char nil)

  (defadvice goto-char (before push-mark-first activate)
    (when push-mark-before-goto-char
      (push-mark)))

  (defun ido-imenu-push-mark ()
    (interactive)
    (let ((push-mark-before-goto-char t))
      (ido-imenu)))
#+END_SRC

#+RESULTS:
: ido-imenu-push-mark

*** smex (auto-complete minibuffer commands called with Meta-x)

#+BEGIN_SRC emacs-lisp
;; Smex: Autocomplete meta-x command
(global-set-key [(meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(meta x)] 'smex)
                  (smex)))

(global-set-key [(shift meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(shift meta x)] 'smex-major-mode-commands)
                  (smex-major-mode-commands)))
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp
(require 'multiple-cursors)
(global-set-key (kbd "C-c m") 'helm-mini)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC

*** Whitespace Mode

#+BEGIN_SRC emacs-lisp
  (defun turn-off-whitespace-mode () (whitespace-mode -1))
  (defun turn-on-whitespace-mode () (whitespace-mode 1))
#+END_SRC

*** Key Chords

#+BEGIN_SRC emacs-lisp
  (require 'key-chord)
  (key-chord-mode 1)

  (defun paren-sexp ()
    (interactive)
    (insert "(")
    (forward-sexp)
    (insert ")"))

  (defun code-quote-sexp ()
    (interactive)
    (insert "=")
    (forward-sexp)
    (insert "="))

  (key-chord-define-global "jk"     'ace-jump-char-mode)
  (key-chord-define-global "jj"     'ace-jump-word-mode)
  (key-chord-define-global "jl"     'ace-jump-line-mode)

  (key-chord-define-global "hj"     'undo)

  (key-chord-define-global "{}"     "{   }\C-b\C-b\C-b")
  (key-chord-define-global "()"     'paren-sexp)
  (key-chord-define-global "(_"     "()\C-b")
  (key-chord-define-global "=="     'code-quote-sexp)

  ;; Exit auto-complete, keeping the current selection,
  ;; while avoiding possible side-effects of TAB or RETURN.
  (key-chord-define-global "KK"      "\C-f\C-b")
  ;; Trick for triggering yasnippet when using in tandem with auto-complete:
  ;; Move forward once to get out of auto-complete, then backward once to
  ;; end of keyword, and enter tab to trigger yasnippet.
  (key-chord-define-global "KL"      "\C-f\C-b\C-i")

  ;; Jump to any symbol in buffer using ido-imenu
  (key-chord-define-global "KJ"      'ido-imenu)
#+END_SRC

*** hl-sexp mode (also: highlight-sexps)

Highlight expressions enclosed by (), {} or [] in code.

There exist 2 versions:

1. hl-sexp package available from elpa.
   Package name: hl-sexp
   Mode name: hl-sexp-mode
2. highlight-sexps.el, from http://www.emacswiki.org/emacs/HighlightSexp.
   Package name: highlight-sexps
   Mode name: highlight-sexps-mode

highlight-sexps.el looks nicer, because it highlights both the innermost s-expression and the one enclosing it, and it does not un-highlight the line where the cursor is on.  But it sometimes stops working.  So I use hl-sexp

#+BEGIN_SRC emacslisp
  (require 'hl-sexp)
  ;; (require 'highlight-sexps)
  ;; Include color customization for dark color theme here.
  (custom-set-variables
   '(hl-sexp-background-colors (quote ("gray0"  "#0f003f"))))
#+END_SRC

*** NEEDS_REVIEW Dired extensions and customization
**** Dired+

#+BEGIN_SRC emacs-lisp
(require 'dired+)
#+END_SRC

**** Dired customization from Healy's startup kit
(From Healy's startup kit)

Note: Perhaps these are not used.  Need to test.

***** Open pdf files with default macos app in dired
:PROPERTIES:
:DATE:     <2013-12-01 Sun 15:01>
:END:

From: http://stackoverflow.com/questions/20019732/define-keybinding-for-dired-to-run-a-command-open-on-the-file-under-the-cur

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "<SPC>")
    (lambda () (interactive)
      (let ((lawlist-filename (dired-get-file-for-visit)))
        (if (equal (file-name-extension lawlist-filename) "pdf")
            (start-process "default-pdf-app" nil "open" lawlist-filename)))))
#+END_SRC
***** Dired-x
Dired extensions
#+SOURCE: Dired-x
#+BEGIN_SRC emacs-lisp
  (load "dired-x")
#+END_SRC

#+RESULTS:
: t

***** Dired open multiple files
In dired mode, visit all marked files using. Bound to the "F" key.
#+SOURCE: dired-F
#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+END_SRC

#+RESULTS:
: my-dired-find-file

***** Stripe Dired buffers
#+name: stripe-dired
#+begin_src [emacs-lisp (This part is disabled)]
(require 'stripe-buffer)
(add-hook 'org-mode-hook 'org-table-stripes-enable)
(add-hook 'dired-mode-hook 'stripe-listify-buffer)
#+end_src

*** TODO Fixme minor mode?

http://www.emacswiki.org/emacs/FixmeMode
http://www.emacswiki.org/emacs/fixme-mode.el

Or see: hl-todo, and further packages like it, listed in hl-todo Help file:

- [[http://emacswiki.org/fic-ext-mode.el][fic-ext-mode]]
- [[https://github.com/lewang/fic-mode][fic-mode]]
- [[http://emacswiki.org/FixmeMode][fixme-mode]]
- [[https://github.com/rolandwalker/fixmee][fixmee]]
- see http://emacswiki.org/FixmeMode for more alternatives

If you like this you might also like [[https://github.com/tarsius/orglink][orglink]].
*** Mac-OS extension: Open file in finder

From: http://stackoverflow.com/questions/20510333/in-emacs-how-to-show-current-file-in-finder

#+BEGIN_SRC emacs-lisp
  (defun open-finder ()
    (interactive)
    ;; IZ Dec 25, 2013 (3:25 PM): Making this work in dired:
    (if (equal major-mode 'dired-mode)
        (open-finder-dired)
        (let ((path
               (if (equal major-mode 'dired-mode)
                   (file-truename (dired-file-name-at-point))
                 (buffer-file-name)))
              dir file)
          (when path
            (setq dir (file-name-directory path))
            (setq file (file-name-nondirectory path))
            (open-finder-1 dir file)))))

  (defun open-finder-1 (dir file)
    (message "open-finder-1 dir: %s\nfile: %s" dir file)
    (let ((script
           (if file
               (concat
                "tell application \"Finder\"\n"
                " set frontmost to true\n"
                " make new Finder window to (POSIX file \"" dir "\")\n"
                " select file \"" file "\"\n"
                "end tell\n")
             (concat
              "tell application \"Finder\"\n"
              " set frontmost to true\n"
              " make new Finder window to {path to desktop folder}\n"
              "end tell\n"))))
      (start-process "osascript-getinfo" nil "osascript" "-e" script)))

#+END_SRC
* Customization of Specific Authoring Modes
** SuperCollider
*** Sclang Setup
#+BEGIN_SRC emacs-lisp
;;; Directory of SuperCollider support, for quarks, plugins, help etc.
(defvar sc_userAppSupportDir
  (expand-file-name "~/Library/Application Support/SuperCollider"))

;; Make path of sclang executable available to emacs shell load path
(add-to-list
 'exec-path
 "/Applications/SuperCollider/SuperCollider.app/Contents/Resources/")

;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; overrides alt-meta switch command
(global-set-key (kbd "C-c W") 'sclang-switch-to-workspace)

;; Disable switching to default SuperCollider Workspace when recompiling SClang
(setq sclang-show-workspace-on-startup nil)

;; Save results of sc evaluation in elisp variable for access in emacs
(defvar sclang-return-string  nil
  "The string returned by sclang process after evaluating expressions.")

(defadvice sclang-process-filter (before provide-sclang-eval-results)
  "Pass sc eval return string to elisp by setting sclang-return-string variable."
  (setq sclang-return-string (ad-get-arg 1)))

(ad-activate 'sclang-process-filter)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'sclang)
#+END_SRC

*** SuperCollider-specific minor modes

Paredit mode breaks re-starting sclang! Therefore, do not use it. Paredit-style bracket movement commands d, u, f, b, n, p work in sclang-mode without loading Paredit.

Sclang-extensions-mode possibly breaks sclang-ac-mode.  Therefore not trying it out for now.

#+BEGIN_SRC emacs-lisp
  ;; paredit mode breaks re-starting sclang! Therefore, do not use it.
  ;; Note: Paredit-style bracket movement commands d, u, f, b, n, p work
  ;; in sclang-mode without loading Paredit.
  ;; (add-hook 'sclang-mode-hook 'paredit-mode)
  (add-hook 'sclang-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'sclang-mode-hook 'hl-sexp-mode)
  (add-hook 'sclang-mode-hook 'sclang-ac-mode)
  ;; Following possibly breaks auto-complete in my setup:  Disabled for now.
  ;; (add-hook 'sclang-mode-hook 'sclang-extensions-mode)
#+END_SRC

*** Sclang keyboard shortcuts

#+BEGIN_SRC emacs-lisp
;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; Show workspace
(global-set-key (kbd "C-c C-M-w") 'sclang-switch-to-workspace)
#+END_SRC
** emacs-lisp
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-whitespace-mode)
  (add-hook 'emacs-lisp-mode-hook 'auto-complete-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC

** org-mode
*** Use visual line, whitespace and windmove in org-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'turn-off-whitespace-mode)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

*** Customize Org-mode display

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t) ;; auto-indent text in subtrees
  (setq org-hide-leading-stars t) ;; hide leading stars in subtree headings
  (setq org-src-fontify-natively t) ;; colorize source-code blocks natively
#+END_SRC

*** Calendar framework: Show org agenda in iCal-style layout

#+BEGIN_SRC emacs-lisp
 (require 'calfw)
#+END_SRC
*** Log: (simplified alternative to capture)
:PROPERTIES:
:DATE:     <2013-12-07 Sat 21:59>
:ID:       1E0A70E5-7417-48E7-B17A-9C727D995AE4
:END:

Time tasks and keep log file, in a very short way

- Very simple and fast input mechanism
- New task simply also sets the timestamp for the end of the previous one.
- Following properties are set:
  START_TIME (= active timestamp set at time of start)
  END_TIME (= active timestamp set at time of start of next log entry)
  TIME_SPAN (= START_TIME--END_TIME as timestamps)
  DURATION (= START_TIME-END_TIME as hours:minutes)
- Keeps current task in file "stopwatch.txt"
  This is read by geeklet CountUp, to display duration of current task.
  (sh code of geeklet is included below).

**** CountUp geeklet code

#+BEGIN_SRC sh
#!/bin/bash
# Homework countdown
# BETA - I will update this when I get more time
function countdown
{
	CURRENT=$(date -j -f %D_%T $1 +%s)
	TARGET=$(date +%s)
	LEFT=$((TARGET-CURRENT))
	WEEKS=$((LEFT/604800))
	DAYS=$(( (LEFT%604800)/86400))
	HOURS=$(( (LEFT%86400)/3600))
	MINS=$(( (LEFT%3600)/60))
	SECS=$((LEFT%60))

	lblWEEKS="Weeks"
	lblDAYS="Days"

	if [ $DAYS == 1 ]
	then
	lblDAYS="Day"
	fi

	if [ $WEEKS == 1 ]
	then
	lblWEEKS="Weeky"
	fi

	if [ $HOURS -lt 10 ]
	then
		HOURS=0$HOURS
	fi

	if [ $MINS -lt 10 ]
	then
		MINS=0$MINS
	fi


	if [ $SECS -lt 10 ]
	then
		SECS=0$SECS
	fi


	echo $2 $HOURS:$MINS:$SECS
	# Optional extra line between timers
	# echo
}
DATES=( $( cat /Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt ) )
# Even numbered indices are names, odd numbered indices are dates

if [ ${#DATES[@]} == 0 ]
then
echo "No Deadlines!"
return
fi

for (( i = 0 ; i < ${#DATES[@]} ; i+=2 ))
do
countdown ${DATES[i+1]} ${DATES[i]}
done
#+END_SRC

**** Emacs-lisp log function

#+BEGIN_SRC emacs-lisp
  (defun log (topic)
    "Write countdown file for countdown geeklet.
    Ask user number of seconds to plan countdown in future."
    (interactive "MEnter task topic: ")
    (if (< (length topic) 1) (setq topic "Untitled task"))
    (let ((timer-string
           (concat
            (replace-regexp-in-string " " "_" topic)
            (format-time-string ": %D_%T" (current-time)))))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt")
      (beginning-of-buffer)
      (kill-line)
      (insert-string timer-string)
      (save-buffer)
      (message (concat "Now timing: " timer-string))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/log.org")
      (widen)
      (end-of-buffer)
      (insert-string "-")
      (org-insert-time-stamp (current-time) t)
      (beginning-of-line)
      (kill-line)
      (if (> (org-outline-level) 1) (outline-up-heading 100 t))
      (org-set-property
       "END_TIME"
       (replace-regexp-in-string
        ">" "]"
        (replace-regexp-in-string "<" "[" org-last-inserted-timestamp)))
      (org-set-property
       "TIMER_SPAN"
       (concat
        (replace-regexp-in-string
         ">" "]"
         (replace-regexp-in-string "<" "[" (org-entry-get (point) "START_TIME")))
        "--"
        (org-entry-get (point) "END_TIME")))
      (let* ((seconds
              (-
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "END_TIME"))))
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "START_TIME"))))
               ))
             (hours (floor (/ seconds 3600)))
             (seconds (- seconds (* 3600 hours)))
             (minutes (floor (/ seconds 60))))
        (org-set-property
         "DURATION"
         (replace-regexp-in-string " " "0" (format "%2d:%2d" hours minutes))))
      (end-of-buffer)
      (insert-string "\n* ")
      (insert-string (replace-regexp-in-string "_" " " timer-string))
      ;;      (insert-string "\n")
      (org-set-property "START_TIME" org-last-inserted-timestamp)
      (org-id-get-create)
      (org-set-tags-command)
  ;;    (if narrow-p
      (org-narrow-to-subtree)
      (goto-char (point-max))
      (org-show-subtree)
      (org-show-entry)
      (save-buffer)
  ;;    )
      ))

  (global-set-key (kbd "C-M-l") 'log)
#+END_SRC

#+RESULTS:
: log
*** Org-Babel: enable some languages

Enable some cool languages in org-babel mode.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (sh . t)
   (ruby . t)
   (python . t)
   (perl . t)
   ))
#+END_SRC

*** Orgmode latex customization

#+BEGIN_SRC emacs-lisp
;;; Load latex package
(require 'ox-latex)

;;; Use xelatex instead of pdflatex, for support of multilingual fonts (Greek etc.)
(setq org-latex-pdf-process (list "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f"))

;;; Add beamer to available latex classes, for slide-presentaton format
(add-to-list 'org-latex-classes
             '("beamer"
               "\\documentclass\[presentation\]\{beamer\}"
               ("\\section\{%s\}" . "\\section*\{%s\}")
               ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
               ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))

;;; Add memoir class (experimental)
(add-to-list 'org-latex-classes
             '("memoir"
               "\\documentclass[12pt,a4paper,article]{memoir}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
*** Org-crypt: Encrypt selected org-mode entries

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** org-reveal: Export slides for Reveal.js from orgmode

Load org-reveal to make slides with reveal.js

#+BEGIN_SRC emacs-lisp
(require 'ox-reveal)
#+END_SRC
*** Macro: toggle drawer visibility for this node
:PROPERTIES:
:DATE:     <2013-12-09 Mon 17:19>
:END:

See: http://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode

#+BEGIN_SRC emacs-lisp
  (fset 'org-toggle-drawer
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 3 16 14 tab 24 24] 0 "%d")) arg)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-d") 'org-toggle-drawer))
#+END_SRC

*** Toggle folding of current item (Command and keyboard command)

#+begin_src emacs-lisp :tangle yes
  (defun org-cycle-current-entry ()
    "toggle visibility of current entry from within the etnry."
    (interactive)
    (save-excursion)
    (outline-back-to-heading)
    (org-cycle))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-/") 'org-cycle-current-entry))
#+end_src

*** Keyboard Command Shortcut: Select heading of this node (for editing)

Note: outline-previous-heading (C-c p) places the point at the beginning of the heading line.  To edit the heading, one has to go past the * that mark the heading.  org-select heading places the mark at the beginning of the heading text and selects the heading, so one can start editing the heading right away.

#+BEGIN_SRC emacs-lisp
  (defun org-select-heading ()
    "Go to heading of current node, select heading."
    (interactive)
    (outline-previous-heading)
    (search-forward (plist-get (cadr (org-element-at-point)) :raw-value))
    (set-mark (point))
    (beginning-of-line)
    (search-forward " "))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-h") 'org-select-heading))
#+END_SRC
*** Encryption

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** Create menu for org-mode entries (lacarte lets you reach it from the keyboard, too)

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda () (imenu-add-to-menubar "Imenu")))
  (setq org-imenu-depth 3)
#+END_SRC

*** making icicle-imenu and icicle-occur work with org-mode

#+BEGIN_SRC emacs-lisp
  (defun org-icicle-occur ()
    "In org-mode, show entire buffer contents before running icicle-occur.
  Otherwise icicle-occur will not place cursor at found location,
  if the location is hidden."
    (interactive)
    (show-all)
    (icicle-occur (point-min) (point-max)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-'") 'org-icicle-occur))

  (defun org-icicle-imenu ()
    "In org-mode, show entire buffer contents before running icicle-imenu.
  Otherwise icicle-occur will not place cursor at found location,
  if the location is hidden."
    (interactive)
    (show-all)
    (icicle-imenu (point-min) (point-max) t))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-=") 'org-icicle-imenu))

  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

*** Providing alternative to refile using icicles

#+BEGIN_SRC emacs-lisp
  (defun org-refile-icy (as-subtree)
    "Alternative to org-refile using icicles.
  Icicles seems to break org-modes headline buffer display, so one
  has to use icicles for all headline navigation if it is loaded.
  If quit with C-g, this function will have removed the section that
  is to be refiled.  To get it back, one has to undo, or paste."
    (interactive "P")
    (outline-back-to-heading)
    (org-cut-subtree)
    (show-all)
    (icicle-imenu (point-min) (point-max) t)
    (outline-next-heading)
    (unless (eq (current-column) 0) (insert "\n"))
    (org-paste-subtree)
    (if as-subtree (org-demote-subtree )))

  ;; Using key binding for org-reveal, since org-reveal
  ;; does nothing for me.
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-R") 'org-refile-icy))
#+END_SRC
** Add git repositories to Magit (git for emacs)

Magit config: Manage git repos from inside emacs

#+BEGIN_SRC emacs-lisp
(setq magit-repo-dirs
      '(
        "~/Dropbox/000WORKFILES/org"
        "~/Documents/Dev"
        "~/.emacs.d/personal"
))
#+END_SRC
